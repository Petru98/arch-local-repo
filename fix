#!/usr/bin/python
import asyncio
import logging
import os
import re
import sys

from cfg import (
    rootdir, log,
    Srcinfo, issrcinfooutdated, iterpkgs,
    run_async, waitall,
    read_srcinfo_async, update_srcinfo_async,
)



def fix(pkgs):
    pkgs_provided = bool(pkgs)
    pkgs = iterpkgs(pkgs, devel=True)
    if not pkgs_provided:
        pkgs = filter(issrcinfooutdated, pkgs)
    del pkgs_provided

    semaphore = asyncio.Semaphore(os.cpu_count())

    # TODO check packages all the packages in the database for existence

    async def fixchecksums(srcinfo):
        async def getchecksum(algo, source, hashval):
            filename, protocol, url = Srcinfo.splitsource(source)
            async with semaphore:
                catcmd = f'curl -Ls \'{url.replace(chr(39), "%27")}\'' if protocol != 'local' else f'cat "{rootdir}/{srcinfo["pkgbase"]}/{url}"'
                stdout, stderr = await run_async(f'{catcmd} | {algo}sum -b',
                    shell=True, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
                )

            stdout = stdout[:stdout.find(' ')].lower()
            if stdout == hashval:
                return None
            return stdout

        hashvalues = set()
        oldchecksums = []
        coros = []

        # Find all checksums for sources
        for suffix in Srcinfo.archsuffixes(srcinfo):
            sources = 'source' + suffix
            if sources in srcinfo:
                for algo in Srcinfo.checksum_algos:
                    checksums = algo + 'sums' + suffix
                    if checksums in srcinfo:
                        for source, checksum in zip(srcinfo[sources], srcinfo[checksums]):
                            hashval = checksum.lower()
                            if hashval != 'skip':
                                if hashval in hashvalues:  # XXX Unlikely. This requires more complex logic when editing the PKGBUILD file. Returning an error should be good enough for now
                                    raise RuntimeError(f'{srcinfo["pkgbase"]}/PKGBUILD contains multiple checksums equal to {checksum}')
                                hashvalues.add(hashval)
                                oldchecksums.append(checksum)
                                coros.append(getchecksum(algo, source, hashval))

        # Find and replace checksum mismatches
        if not hashvalues:
            return
        del hashvalues

        replacements = sorted(filter(lambda x: x[1], zip(oldchecksums, await asyncio.gather(*coros))), key=lambda x: len(x[0]), reverse=True)
        if not replacements:
            return

        oldchecksums, _ = zip(*replacements)
        replacements = dict(replacements)

        with open(f'{rootdir}/{srcinfo["pkgbase"]}/PKGBUILD', 'r+') as fd:
            contents = re.sub('|'.join(oldchecksums), lambda m: replacements[m.group(0)], fd.read())
            fd.seek(0)
            fd.write(contents)

    async def fixpkg_async(pkgbase):
        async with semaphore:
            srcinfo = Srcinfo.parsestr(await read_srcinfo_async(pkgbase, cache=True))

        await fixchecksums(srcinfo)

        if issrcinfooutdated(pkgbase):
            await update_srcinfo_async(pkgbase)

    return asyncio.run(waitall(map(fixpkg_async, pkgs)))



def main(args=sys.argv[1:]):
    import argparse
    argparser = argparse.ArgumentParser(description='', allow_abbrev=False)
    argparser.add_argument('--verbose', '-v', action='store_true', help='Show more info.')
    argparser.add_argument('pkgs', metavar='PKGS', nargs='*', help='Packages to fix.')

    args = argparser.parse_args(args)
    if args.verbose:
        log.setLevel(logging.INFO)

    return fix(args.pkgs)


if __name__ == '__main__':
    exit(main())
